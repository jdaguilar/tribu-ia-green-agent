{
    "id": "code_gen_002",
    "category": "code_generation",
    "difficulty": "easy",
    "title": "Separate Parentheses Groups",
    "description": "Write a function that takes a string of multiple groups of nested parentheses and separates them into individual strings.",
    "specification": {
        "function_name": "separate_paren_groups",
        "parameters": [
            {
                "name": "paren_string",
                "type": "str"
            }
        ],
        "return_type": "List[str]",
        "constraints": [
            "Input consists only of '(' and ')'",
            "Every opening parenthesis has a matching closing parenthesis"
        ]
    },
    "prompt": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    pass",
    "test_code": "def test_separate_paren_groups():\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == ['(()())', '((()))', '()', '((())()())']\n    assert separate_paren_groups('() (()) ((())) (((())))') == ['()', '(())', '((()))', '(((())))']\n    assert separate_paren_groups('(()(())((())))') == ['(()(())((())))']\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']",
    "reference_solution": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result",
    "metadata": {
        "time_limit_seconds": 60,
        "max_tokens": 1000,
        "tags": [
            "strings",
            "parsing"
        ]
    }
}